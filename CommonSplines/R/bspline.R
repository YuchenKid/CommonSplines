#' Generating B-spline basis
#'
#' This function generates B-spline basis. The B-splines are defined following
#' the recursive formulas due to de Boor. Only univariate input can be used.
#'
#' @param x The input vector of training dataset.
#' @param y The output vector of training dataset.
#' @param order The order of B-spline functions. The default is order=4 for cubic B-splines.
#' @param innerknots The internal knots that define the spline. \code{innerknots} should not contain knots on the boundary.
#' @return A list with the following components:
#' \item{beta}{ The coefficients of nonparametric regression.}
#' \item{basis}{The B-spline basis matrix of dimension c(length(x), df). df = length(innerknots) + order.}
#' \item{knots}{The knots used to construct the B-splines, including innerknots, boundary knots and phantom knots}
#' \item{order}{The order of basis functions. order=degree+1}
#' @examples
#' x<-seq(0, 1, 0.001)
#' y <- x^3 * 3 - x^2 * 2 + x + exp(1)+rnorm(length(x),0,0.1)
#' plot(x,y)
#' innerknots <- seq(0.1, 0.9, 0.1)
#' order<-4
#'
#' basis<-bsplineBasis(x,y,order,innerknots)
#' plot(x,rep(0,length(x)),type="l",ylim=c(0,1))
#' for (i in 1: (length(innerknots)+order)){
#'   lines(x,basis$basismatrix[,i])
#' }
#' @export
bsplineBasis <-function (x,y,order,innerknots) #degree<-order-1
{
  highknot = max(x)
  lowknot = min(x)
  innerknots <- unique (sort (innerknots))
  #knots <-c(rep(lowknot, order), innerknots, rep(highknot, order))
  knots <-c(rep(lowknot-0.0001, order-1),lowknot, innerknots,highknot, rep(highknot+0.0001, order-1))
  n <- length (x)
  j <- length (innerknots) # j+order basis functions
  G <- matrix (0,  nrow=n,ncol=(j+2*order-1)) # matrix G is n*(J+q) dimensional, used for coefficient estimation.
  for (i in 1: (j+2*order-1)){
    G[,i]<-ifelse((x>=knots[i]&x<knots[i+1]),1,0)
  }
  for (k in 2:order){
    N<-G
    for (i in 1: (j+2*order-k)){
      if((knots[i+(k-1)]-knots[i])==0&&(knots[i+k]-knots[i+1])==0){
        G[,i]<-rep(0,n)
      }else if ((knots[i+(k-1)]-knots[i])==0){
        G[,i]<-(knots[i+k]-x)/(knots[i+k]-knots[i+1])*N[,(i+1)]
      }else if ((knots[i+k]-knots[i+1])==0){
        G[,i]<-(x-knots[i])/(knots[i+(k-1)]-knots[i])*N[,i]
      }else{
        G[,i]<-(x-knots[i])/(knots[i+(k-1)]-knots[i])*N[,i]+(knots[i+k]-x)/(knots[i+k]-knots[i+1])*N[,(i+1)]
      }
    }
  }
  Gb<-G[,1:(j+order)]
  beta<-(solve(t(Gb)%*%Gb))%*%t(Gb)%*%y
  solution<-list("beta"=beta ,"basismatrix" = Gb,"knots"=knots, "order"=order)
  return (solution)
}
#' Regression using B-spline basis
#'
#' This function provides nonparametric regressions using B-splines. The B-splines are generated by the function \code{bsplinBasis}.
#' The return value of \code{bsplinBasis} is required as an argument of \code{bsplineFitting}
#'
#' @param x_test The input values at which evaluations are required.
#' @param basis The return value of function \code{bsplinBasis}.
#' @return The evaluated output at x_test.
#' @examples
#' x<-seq(0, 1, 0.001)
#' y <- x^3 * 3 - x^2 * 2 + x + exp(1)+rnorm(length(x),0,0.1)
#' plot(x,y)
#' innerknots <- seq(0.1, 0.9, 0.01)
#' order<-4

#' basis<-bsplineBasis(x,y,order,innerknots)
#'
#' x_test<-seq(0, 1, 0.01)
#' fit<-bsplineFitting(x_test,basis)

#' plot(x_test,fit)
#' lines(x_test,x_test^3 * 3 - x_test^2 * 2 + x_test + exp(1),col="red")
#' @export
bsplineFitting<-function (x_test,basis) #basis<-bsplineBasis(x,y,order,innerknots)
{
  knots <-basis$knots
  order<-basis$order
  j<-length(knots)-2*order
  m<-length(x_test)
  phi <- matrix (0,  nrow=m,ncol=(j+2*order-1))
  for (i in 1: (j+2*order-1)){
    phi[,i]<-ifelse((x_test>=knots[i]&x_test<knots[i+1]),1,0)
  }
  for (k in 2:order){
    N<-phi
    for (i in 1: (j+2*order-k)){
      if((knots[i+(k-1)]-knots[i])==0&&(knots[i+k]-knots[i+1])==0){
        phi[,i]<-rep(0,m)
      }else if ((knots[i+(k-1)]-knots[i])==0){
        phi[,i]<-(knots[i+k]-x_test)/(knots[i+k]-knots[i+1])*N[,(i+1)]
      }else if ((knots[i+k]-knots[i+1])==0){
        phi[,i]<-(x_test-knots[i])/(knots[i+(k-1)]-knots[i])*N[,i]
      }else{
        phi[,i]<-(x_test-knots[i])/(knots[i+(k-1)]-knots[i])*N[,i]+(knots[i+k]-x_test)/(knots[i+k]-knots[i+1])*N[,(i+1)]
      }
    }
  }
  phi_b<-phi[,1:(j+order)]
  f<-phi_b%*%basis$beta
  return (f)
}

