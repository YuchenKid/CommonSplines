#' Generating B-spline basis
#'
#' This function generates B-spline basis. The B-splines are defined following
#' the recursive formulas due to de Boor. Only univariate input can be used.
#'
#' @param x The input vector of training dataset.
#' @param y The output vector of training dataset.
#' @param order The order of B-spline functions. The default is order=4 for cubic B-splines.
#' @param innerknots The internal knots that define the spline. \code{innerknots} should not contain knots on the boundary.
#' @return A list with the following components:
#' \item{beta}{ The coefficients of nonparametric regression.}
#' \item{basis}{The B-spline basis matrix of dimension c(length(x), df). df = length(innerknots) + order.}
#' \item{knots}{The knots used to construct the B-splines, including innerknots, boundary knots and phantom knots}
#' \item{order}{The order of basis functions. order=degree+1}
#' @examples
#' x<-seq(0, 1, 0.001)
#' y <- x^3 * 3 - x^2 * 2 + x + exp(1)+rnorm(length(x),0,0.1)
#' plot(x,y)
#' innerknots <- seq(0.1, 0.9, 0.1)
#' order<-4
#'
#' basis<-bsplineBasis(x,y,order,innerknots)
#' plot(x,rep(0,length(x)),type="l",ylim=c(0,1))
#' for (i in 1: (length(innerknots)+order)){
#'   lines(x,basis$basismatrix[,i])
#' }
#' @export
bsplineBasis <-function (x,y,order,innerknots) #degree<-order-1
{
  highknot = max(x)
  lowknot = min(x)
  innerknots <- unique (sort (innerknots))
  #knots <-c(rep(lowknot, order), innerknots, rep(highknot, order))
  knots <-c(rep(lowknot-0.0001, order-1),lowknot, innerknots,highknot, rep(highknot+0.0001, order-1))
  n <- length (x)
  j <- length (innerknots) # j+order basis functions
  G <- matrix (0,  nrow=n,ncol=(j+2*order-1)) # matrix G is n*(J+q) dimensional, used for coefficient estimation.
  for (i in 1: (j+2*order-1)){
    G[,i]<-ifelse((x>=knots[i]&x<knots[i+1]),1,0)
  }
  for (k in 2:order){
    N<-G
    for (i in 1: (j+2*order-k)){
      if((knots[i+(k-1)]-knots[i])==0&&(knots[i+k]-knots[i+1])==0){
        G[,i]<-rep(0,n)
      }else if ((knots[i+(k-1)]-knots[i])==0){
        G[,i]<-(knots[i+k]-x)/(knots[i+k]-knots[i+1])*N[,(i+1)]
      }else if ((knots[i+k]-knots[i+1])==0){
        G[,i]<-(x-knots[i])/(knots[i+(k-1)]-knots[i])*N[,i]
      }else{
        G[,i]<-(x-knots[i])/(knots[i+(k-1)]-knots[i])*N[,i]+(knots[i+k]-x)/(knots[i+k]-knots[i+1])*N[,(i+1)]
      }
    }
  }
  Gb<-G[,1:(j+order)]
  beta<-(solve(t(Gb)%*%Gb))%*%t(Gb)%*%y
  solution<-list("beta"=beta ,"basismatrix" = Gb,"knots"=knots, "order"=order)
  return (solution)
}
#' Regression using B-spline basis
#'
#' This function provides nonparametric regressions using B-splines. The B-splines are generated by the function \code{bsplinBasis}.
#' The return value of \code{bsplinBasis} is required as an argument of \code{bsplineFitting}
#'
#' @param x_test The input values at which evaluations are required.
#' @param basis The return value of function \code{bsplinBasis}.
#' @return The evaluated output at x_test.
#' @examples
#' x<-seq(0, 1, 0.001)
#' y <- x^3 * 3 - x^2 * 2 + x + exp(1)+rnorm(length(x),0,0.1)
#' plot(x,y)
#' innerknots <- seq(0.1, 0.9, 0.01)
#' order<-4

#' basis<-bsplineBasis(x,y,order,innerknots)
#'
#' x_test<-seq(0, 1, 0.01)
#' fit<-bsplineFitting(x_test,basis)

#' plot(x_test,fit)
#' lines(x_test,x_test^3 * 3 - x_test^2 * 2 + x_test + exp(1),col="red")
#' @export
bsplineFitting<-function (x_test,basis) #basis<-bsplineBasis(x,y,order,innerknots)
{
  knots <-basis$knots
  order<-basis$order
  j<-length(knots)-2*order
  m<-length(x_test)
  phi <- matrix (0,  nrow=m,ncol=(j+2*order-1))
  for (i in 1: (j+2*order-1)){
    phi[,i]<-ifelse((x_test>=knots[i]&x_test<knots[i+1]),1,0)
  }
  for (k in 2:order){
    N<-phi
    for (i in 1: (j+2*order-k)){
      if((knots[i+(k-1)]-knots[i])==0&&(knots[i+k]-knots[i+1])==0){
        phi[,i]<-rep(0,m)
      }else if ((knots[i+(k-1)]-knots[i])==0){
        phi[,i]<-(knots[i+k]-x_test)/(knots[i+k]-knots[i+1])*N[,(i+1)]
      }else if ((knots[i+k]-knots[i+1])==0){
        phi[,i]<-(x_test-knots[i])/(knots[i+(k-1)]-knots[i])*N[,i]
      }else{
        phi[,i]<-(x_test-knots[i])/(knots[i+(k-1)]-knots[i])*N[,i]+(knots[i+k]-x_test)/(knots[i+k]-knots[i+1])*N[,(i+1)]
      }
    }
  }
  phi_b<-phi[,1:(j+order)]
  f<-phi_b%*%basis$beta
  return (f)
}
#' Train a smoothing spline with squared 2nd derivative penalty using natural cubic spline
#'
#' This function trains a smoothing spline with squared 2nd derivative penalty. It has an explicit,finite-dimensional,
#' unique minimizer which is a natural cubic spline. This function can be used for small or moderate number of knots. When the number of data N<=50, all knots are included.
#' When N>50, 50 knots are uniformly chosen from the training dataset.
#'
#' @param x The input vector of training dataset.
#' @param y The output vector of training dataset.
#' @param lambda A fixed smoothing parameter.
#' @return A list with the following components:
#' \item{beta}{ The coefficients of natural splines.}
#' \item{S}{The smoother matrix.}
#' \item{knots}{The knots used to construct the B-splines, including innerknots, boundary knots and phantom knots}
#' @examples
#' x<-seq(0, 1, 0.001)
#' y <- x^3 * 3 - x^2 * 2 + x + exp(1)+rnorm(length(x),0,0.1)
#' plot(x,y)
#' lambda<-0.001
#'
#' basis<-CubicSmoothingSpline_Train(x,y,lambda)
#' cat("the knots chosen are: ",basis$knots)
#' @export

CubicSmoothingSpline.Train<-function (x,y,lambda)
{
  if (length(x)<=51){
    basis<- natural_cubic_splines.train(x, y, knots=x/max(x))
  }else{
    knots<-seq(0,1,0.02)
    x_knots<-numeric(51)
    y_knots<-numeric(51)
    x_knots[1]<-x[1]
    y_knots[1]<-y[1]
    x_knots[51]<-x[length(x)]
    y_knots[51]<-y[length(y)]
    for(i in 2:50){
      j<-floor(knots[i]*length(x))
      x_knots[i]<-x[j+1]
      y_knots[i]<-y[j+1]
    }
    basis<- natural_cubic_splines.train(x_knots, y_knots, knots=x_knots/max(x_knots))
  }
  knots<-unname(basis$knots)
  h<-numeric(length(knots)-1)
  for (i in 1:length(h)){
    h[i]<-knots[i+1]-knots[i]
  }
  delta<-matrix(0,nrow=length(knots)-2,ncol=length(knots))
  w<-matrix(0,nrow=length(knots)-2,ncol=length(knots)-2)
  for(i in 1:(length(knots)-2)){
    delta[i,i]<-1/h[i]
    delta[i,i+1]<--1/h[i]-1/h[i+1]
    delta[i,i+2]<-1/h[i+1]
    w[i-1,i]<-h[i]/6
    w[i,i-1]<-h[i]/6
    w[i,i]<-(h[i]+h[i+1])/3
  }
  K<-t(delta)%*%solve(w)%*%delta
  I<-diag(length(knots))
  if((length(x)<=51)){
    S<-solve(I+lambda*K)%*%y
  }else{
    S<-solve(I+lambda*K)%*%y_knots
  }
  beta<-solve(basis$N)%*%S
  #f<-basis$N%*%S
  if((length(x)<=51)){
    solution<-list("beta"=beta,"S" = S, "knots"=x)
  }else{
    solution<-list("beta"=beta,"S" = S, "knots"=x_knots)
  }
  return(solution)
}
#' Prediction using smoothing spline with squared 2nd derivative penalty
#'
#' This function takes the coefficients trained by \code{CubicSmoothingSpline.Train} and evaluate the output at x_test
#'
#' @param x_test The input values at which evaluations are required.
#' @param basis The return value of function \code{CubicSmoothingSpline.Train}.
#' @return The evaluated output at x_test.
#' @examples
#' x<-seq(0, 1, 0.0015)
#' y <- x^3 * 3 - x^2 * 2 + x + exp(1)+rnorm(length(x),0,0.1)
#' plot(x,y)
#' lambda<-0.001
#' basis<-CubicSmoothingSpline.Train(x,y,lambda)
#'
#' x_test<-seq(0, 1, 0.1)
#' fit<-CubicSmoothingSpline.Fitting(basis,x_test)
#'
#' plot(x_test,fit)
#' lines(x_test,x_test^3 * 3 - x_test^2 * 2 + x_test + exp(1),col="red")

#' @export
CubicSmoothingSpline.Fitting<-function (basis,x_test)
{
  N_test<-natural_cubic_splines.eval_basis(x_test, basis$knots, length(basis$knots))
  f<-N_test%*%basis$beta
  return (f)
}

